import streamlit as st
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px 
import plotly.graph_objects as go
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error

# Load Data
# To run into local machine uncomment this line
df = pd.read_excel('supermarkt_sales.xlsx', skiprows=3)

# To deploy this on streamlit page, please uncomment this one.
#df = pd.read_excel('/mount/src/data-engineering-tools/Streamlit-web-application/supermarkt_sales/supermarkt_sales.xlsx', skiprows=3)

# Drop the first column
df = df.drop(df.columns[0], axis=1)

# Preprocess Data
df_encoded = pd.get_dummies(df, columns=['Branch', 'City', 'Customer_type', 'Gender', 'Product line', 'Payment'], drop_first=True)

X = df_encoded[['Quantity', 'Unit price', 'gross income']]
y = df_encoded['Total']

# Split Data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Train Model
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

#===================================================================================================
# ====================== Streamlit app ========================
st.set_page_config(page_title="Sales Dashboard", page_icon=":bar_chart:", layout="wide")
st.title(":bar_chart: _Sales Dashboard_ created by :blue[Arun] :sunglasses:")
st.header("", divider=True)

# Add developer information
st.markdown("""
    <span style="color:orange;"><b>Name of the Developer:</b></span> Arun Kumar Pandey  
    <span style="color:green;"><b>GitHub Repo:</b></span> [Sales Data dashboard](https://github.com/arunp77/Data-engineering-tools/tree/main/Streamlit-web-application/supermarkt_sales)  
    <span style="color:rgb(26, 188, 156);"><b>Email ID:</b></span> arunp77@gmail.com
""", unsafe_allow_html=True)

st.subheader("", divider=True)

# Sidebar for navigation
st.sidebar.title("Navigation")
option = st.sidebar.radio("Select Analysis", ('Data Overview', 'Actual vs Predicted', 'Residual Plot', 'Residuals Distribution', 'Model Performance', 'Learning Curve'))

# Filters
city = st.sidebar.multiselect("Select the City:", options=df["City"].unique(), default=df["City"].unique())
customer_type = st.sidebar.multiselect("Select the Customer Type:", options=df["Customer_type"].unique(), default=df["Customer_type"].unique())
gender = st.sidebar.multiselect("Select the Gender:", options=df["Gender"].unique(), default=df["Gender"].unique())
card_type = st.sidebar.multiselect("Select payment method:", options=df['Payment'].unique(), default=df["Payment"].unique())

# Correct the query by using 'Payment' in the filter
df_selection = df.query("City == @city & Customer_type == @customer_type & Gender == @gender & Payment == @card_type")

# Check if the dataframe is empty:
if df_selection.empty:
    st.warning("No data available based on the current filter settings!")
    st.stop()

# ---- MAIN PAGE ----
st.markdown("##")

#===================================================================================================


# 1. Data Overview
if option == 'Data Overview':
    st.header('Data Overview')
    st.dataframe(df_selection.head())
    # st.write(df_selection.head())
    st.caption("Top 5 rows of the dataset.")
    st.write(df_selection.describe())
    st.caption("The table above provides a statistical summary of the dataset, including metrics such as count, mean, standard deviation, minimum, and maximum values for each numerical column.")

    # Gender Distribution Plot
    st.subheader('Gender Distribution')
    gender_dist = px.histogram(df_selection, x="Gender", title="Gender Distribution", width=600, height=400)
    st.plotly_chart(gender_dist)
    st.caption("The histogram shows the distribution of customers by gender, with nearly equal representation of females (501) and males (499).")
    

    # Sales by City
    st.subheader('Sales by City')
    city_sales = df_selection.groupby('City')['Total'].sum().reset_index()
    city_sales_plot = px.bar(city_sales, x='City', y='Total', title="Total Sales by City", width=600, height=400)
    st.plotly_chart(city_sales_plot)
    st.caption("This bar chart highlights the total sales generated by each city, providing a clear view of regional performance.")
    
    
    # Sales by Product Line
    st.subheader('Sales by Product Line')
    product_sales = df_selection.groupby('Product line')['Total'].sum().sort_values(ascending=False)
    product_sales_plot = px.bar(x=product_sales.index, y=product_sales.values, title="Understand which product lines generate the most revenue", width=600, height=400)
    st.plotly_chart(product_sales_plot)
    st.caption("This chart shows the total sales by product line, helping to identify the top revenue-generating product categories.")

    # ---- Customer Type and Payment Method Crosstab ----
    st.subheader('Customer Type and Payment Method')
    # Create a crosstab using pandas
    customer_payment_crosstab = pd.crosstab(df_selection['Customer_type'], df_selection['Payment']) # "Analyze which customer type uses which payment method"
    # Plot the crosstab as a stacked bar chart using Plotly
    fig = go.Figure()
    for payment_method in customer_payment_crosstab.columns:
        fig.add_trace(
            go.Bar(
                x=customer_payment_crosstab.index,
                y=customer_payment_crosstab[payment_method],
                name=payment_method
            )
        )

    # Customize the layout
    fig.update_layout(
        barmode='stack',
        title="Customer Type vs Payment Method",
        xaxis_title="Customer Type",
        yaxis_title="Count",
        legend_title="Payment Method",
        width=800, height=600
    )

    # Display the plot
    st.plotly_chart(fig)
    st.caption("The stacked bar chart illustrates which customer types prefer which payment methods, offering insights into customer behavior.")
    
    #------------------------------------------------------------
    # Sales Over Time: If you want to analyze sales trends over time
    st.subheader('Sales Over Time')
    # Ensure the 'Date' column is in datetime format
    df_encoded['Date'] = pd.to_datetime(df_encoded['Date'])
    # Group by Date to get daily sales
    daily_sales = df_encoded.groupby('Date')['Total'].sum().reset_index()
    # Plot using plotly
    fig = px.line(daily_sales, x='Date', y='Total', title='Analyzing sales trends over time', width=800, height=600)

    # Display the plot
    st.plotly_chart(fig)
    st.caption("This line plot tracks total sales over time, revealing key trends and patterns in customer purchases.")
    
    #-------------------------------------------------------------
    # Correlation Heatmap
    st.subheader('Correlation Heatmap')
    # Calculate the correlation matrix
    correlation = df[['Unit price', 'Quantity', 'Total', 'gross income', 'Rating']].corr()
    # Plot heatmap using Plotly
    fig = px.imshow(correlation, 
                    text_auto=True, 
                    color_continuous_scale='RdBu_r', 
                    title='Correlation Heatmap',
                    width=900, height=900)

    st.plotly_chart(fig)
    st.caption("This heatmap displays the correlation between key variables like unit price, quantity, total sales, and customer ratings.")

    #----------------------------------
    # Customer Segmentation
    st.subheader('Customer Segmentation by Spending')

    # Function to categorize customers based on total spending
    def categorize_customer(total):
        if total < 200:
            return 'Low Spender'
        elif 200 <= total < 500:
            return 'Medium Spender'
        else:
            return 'High Spender'

    # Apply customer category
    df['Customer Category'] = df['Total'].apply(categorize_customer)

    # Count the occurrences of each customer category
    customer_segments = df['Customer Category'].value_counts().reset_index()

    # Rename columns to make them more descriptive
    customer_segments.columns = ['Customer Category', 'count']

    # Plot customer segments using Plotly
    fig = px.bar(customer_segments, x='Customer Category', y='count', 
                title='', 
                labels={'count': 'Number of Customers'},
                width=800, height=600)
    st.plotly_chart(fig)
    st.caption("This bar chart categorizes customers based on their total spending into low, medium, and high spenders.")

    #----------------------------------
    # Sales by Time of Day
    st.subheader('Sales by Time of Day')
    # Group sales by time
    time_sales = df.groupby('Time')['Total'].sum().reset_index()
    # Plot using Plotly
    fig = px.line(time_sales, x='Time', y='Total', title='', labels={'Total': 'Total Sales'}, width=800, height=600)
    st.plotly_chart(fig)
    st.caption("This line chart visualizes total sales across different times of the day, helping to identify peak shopping hours.")
    
    #----------------------------------
    # Gross Income by Branch
    st.subheader('Gross Income by Branch')
    # Group by branch
    branch_income = df.groupby('Branch')['gross income'].sum().reset_index()
    # Plot using Plotly
    fig = px.bar(branch_income, x='Branch', y='gross income', title='', labels={'gross income': 'Gross Income'}, width=800, height=600)
    st.plotly_chart(fig)
    st.caption("This bar chart shows the gross income generated by each branch, highlighting the most profitable locations.")
    
    #===========================================================

    #----------------------------------
    # Rating Distribution
    st.subheader('Distribution of Customer Ratings')
    # Plot histogram using Plotly
    fig = px.histogram(
        df, 
        x='Rating', 
        nbins=20, 
        # title='Distribution of Customer Ratings', 
        marginal='box',  # Adds a boxplot to visualize the spread
        width=800, 
        height=600,
        labels={'Rating': 'Customer Rating'},
        color_discrete_sequence=['#1f77b4'],  # Change to a more vibrant blue color
    )
    # Update layout for better aesthetics
    fig.update_layout(
        # title_font=dict(size=20, family='Arial', color='white'),  # Customize title font
        xaxis_title='Customer Rating',
        yaxis_title='Count',
        bargap=0.2,  # Adds some space between bars for readability
        plot_bgcolor='rgba(0,0,0,0)',  # Make the background transparent
        paper_bgcolor='rgba(0,0,0,0)',  # Light background for the entire plot
    )

    # Customize axis ticks and gridlines
    fig.update_xaxes(showgrid=False, gridwidth=0.5, gridcolor='lightgray')
    fig.update_yaxes(showgrid=False, gridwidth=0.5, gridcolor='lightgray')
    
    st.plotly_chart(fig)
    st.caption("The histogram shows the distribution of customer ratings, offering insights into overall satisfaction levels.")


    #----------------------------------
    # Rating based on Product Line
    st.subheader('Customer Ratings by Product Line')
    # Boxplot using Plotly
    fig = px.box(df, x='Product line', y='Rating', title='Customer Ratings by Product Line', labels={'Rating': 'Rating'}, width=800, height=600)
    fig.update_xaxes(tickangle=45)
    st.plotly_chart(fig)
    st.caption("This boxplot compares customer ratings across different product lines, helping to evaluate customer satisfaction by category.")



# 2. Actual vs Predicted Plot
if option == 'Actual vs Predicted':
    st.header('Actual vs Predicted Sales')
    scatter_plot = px.scatter(x=y_test, y=y_pred, labels={'x': 'Actual Sales', 'y': 'Predicted Sales'}, title="Actual vs Predicted Sales", width=800, height=600)
    st.plotly_chart(scatter_plot)

# 3. Residual Plot
if option == 'Residual Plot':
    st.header('Residual Plot')
    residuals = y_test - y_pred
    residual_plot = px.scatter(x=y_pred, y=residuals, labels={'x': 'Predicted Sales', 'y': 'Residuals'}, title="Residual Plot", width=800, height=600)
    residual_plot.add_hline(y=0, line_dash="dash", line_color="red")
    st.plotly_chart(residual_plot)

# 4. Residual Distribution
if option == 'Residuals Distribution':
    st.header('Distribution of Residuals')
    residuals = y_test - y_pred
    residual_dist = px.histogram(residuals, nbins=50, marginal='violin', title="Distribution of Residuals", width=800, height=600)
    st.plotly_chart(residual_dist)

# 5. Model Performance
if option == 'Model Performance':
    st.header('Model Performance Metrics')
    r_squared = r2_score(y_test, y_pred)
    mse = mean_squared_error(y_test, y_pred)

    st.write(f"**R-squared:** {r_squared:.3f}")
    st.write(f"**Mean Squared Error (MSE):** {mse:.3f}")

    # Bar plot for R-squared and MSE
    performance_fig = go.Figure(go.Bar(x=['R-squared', 'MSE'], y=[r_squared, mse], marker_color=['blue', 'green']))
    performance_fig.update_layout(title_text="Model Performance Metrics", yaxis_title="Score", width=800, height=600)
    st.plotly_chart(performance_fig)

# 6. Learning Curve (if you've implemented it)
if option == 'Learning Curve':
    from sklearn.model_selection import learning_curve

    st.header('Learning Curve')
    train_sizes, train_scores, test_scores = learning_curve(model, X, y, cv=5, scoring='r2', n_jobs=-1)
    train_scores_mean = train_scores.mean(axis=1)
    test_scores_mean = test_scores.mean(axis=1)

    # Plot learning curve
    learning_curve_fig = go.Figure()
    learning_curve_fig.add_trace(go.Scatter(x=train_sizes, y=train_scores_mean, mode='lines', name='Training Score'))
    learning_curve_fig.add_trace(go.Scatter(x=train_sizes, y=test_scores_mean, mode='lines', name='Validation Score'))
    learning_curve_fig.update_layout(title='Learning Curve', xaxis_title='Training Size', yaxis_title='R-squared Score', width=800, height=600)
    st.plotly_chart(learning_curve_fig)
